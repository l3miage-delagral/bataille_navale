{"ast":null,"code":"import { tap, scan, map, Subject, delay, switchMap, shareReplay, startWith, BehaviorSubject, filter } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nfunction grid(g, [x, y]) {\n  let v;\n  switch (g[x][y]) {\n    case 'boat':\n      v = 'touched';\n      break;\n    case 'water':\n      v = 'missed';\n      break;\n    default:\n      v = g[x][y];\n  }\n  return g.map((L, i) => i != x ? L : L.map((c, j) => j != y ? c : v));\n}\nfunction* gen(nb) {\n  for (let i = 0; i < nb; i++) {\n    yield i;\n  }\n}\nconst N = 10;\nexport let GameService = /*#__PURE__*/(() => {\n  class GameService {\n    ngOnDestroy() {\n      console.log('destroy GameService');\n      this.Lsub.forEach(s => s.unsubscribe());\n    }\n    constructor() {\n      this.subjData = new Subject();\n      this.subjShot = new Subject();\n      this.bsState = new BehaviorSubject({\n        turn: 'player',\n        player: {\n          data: {\n            boats: [],\n            shots: []\n          },\n          grid: []\n        },\n        opponent: {\n          data: {\n            boats: [],\n            shots: []\n          },\n          grid: []\n        }\n      });\n      this.Lsub = [];\n      console.log('new GameService');\n      this.Lsub.push(this.subjData.pipe(tap(D => console.log('new data for state', D)), map(data => ({\n        // produce an initial STATE\n        turn: data.turn,\n        player: {\n          data: data.player,\n          grid: this.getGridFromBoats(data.player.boats)\n        },\n        opponent: {\n          data: data.opponent,\n          grid: this.getGridFromBoats(data.opponent.boats)\n        }\n      })), switchMap(S => {\n        return this.subjShot.pipe(scan((state, {\n          orderFrom: shooter,\n          at: shootAt\n        }) => {\n          const {\n            turn,\n            player,\n            opponent\n          } = state;\n          if (turn !== shooter) return state;\n          const P = turn === 'player' ? state.opponent : state.player;\n          const nP = {\n            data: {\n              ...P.data,\n              shots: [...P.data.shots, shootAt]\n            },\n            grid: grid(P.grid, shootAt)\n          };\n          const newState = state.turn === 'opponent' ? {\n            turn: 'player',\n            player: nP,\n            opponent\n          } : {\n            turn: 'opponent',\n            player,\n            opponent: nP\n          };\n          return newState;\n        }, S), startWith(S));\n      }), tap(console.log), shareReplay(1)).subscribe(this.bsState)); // endof push\n      this.Lsub.push(this.bsState.pipe(filter(s => s.turn === 'opponent'), delay(100)).subscribe(state => {\n        let L = [];\n        state.player.grid.forEach((row, i) => row.forEach((col, j) => {\n          if (col === 'water' || col === 'boat') {\n            L.push([i, j]);\n          }\n        }));\n        console.log('opponent play');\n        if (L.length) {\n          const at = L[Math.floor(Math.random() * L.length)];\n          console.log('  at', at);\n          this.shoot({\n            orderFrom: 'opponent',\n            at\n          });\n        }\n      }));\n      this.obsState = this.bsState.asObservable();\n      this.reset();\n    }\n    shoot(s) {\n      if (this.bsState.value.turn === s.orderFrom) {\n        this.subjShot.next(s);\n        return {\n          status: 'OK'\n        };\n      }\n      return {\n        status: 'error',\n        error: `not the turn of ${s.orderFrom}`\n      };\n    }\n    reset(turn = 'player') {\n      this.subjData.next({\n        turn,\n        player: {\n          boats: this.getBoats(),\n          shots: []\n        },\n        opponent: {\n          boats: this.getBoats(),\n          shots: []\n        }\n      });\n    }\n    getGridFromBoats(L) {\n      const G = Array(N).fill(false).map(L => Array(N).fill('water'));\n      L.forEach(({\n        upperLeft: [x1, y1],\n        lowerRight: [x2, y2]\n      }) => {\n        for (let i = x1; i <= x2; i++) {\n          for (let j = y1; j <= y2; j++) {\n            G[i][j] = 'boat';\n          }\n        }\n      });\n      return G;\n    }\n    getBoats() {\n      const G = Array(N).fill(false).map(L => Array(N).fill(false));\n      const LB = [];\n      [5, 4, 3, 3, 3, 2, 2, 2, 1, 1].forEach(s => {\n        let placed = false;\n        do {\n          const [x, y] = this.getCoord(N, N);\n          if (G[x][y]) continue;\n          // Try any direction\n          const directions = [...[[1, 0], [-1, 0], [0, 1], [0, -1]]];\n          while (directions.length > 0 && !placed) {\n            const pos = Math.floor(directions.length * Math.random());\n            const [dx, dy] = directions[pos];\n            directions.splice(pos, 1);\n            if ([...gen(s)].reduce((occ, n) => occ && G[x + n * dx]?.[y + n * dy] === false, true)) {\n              // Aucune case déjà occupée\n              const [ex, ey] = [x + (s - 1) * dx, y + (s - 1) * dy];\n              const upperLeft = [Math.min(x, ex), Math.min(y, ey)];\n              const lowerRight = [Math.max(x, ex), Math.max(y, ey)];\n              // Ajouter le bateau\n              LB.push({\n                upperLeft,\n                lowerRight\n              });\n              // Mettre à jour la grille\n              [...gen(s)].forEach(n => G[x + n * dx][y + n * dy] = true);\n              // Placé !\n              placed = true;\n            }\n          }\n        } while (!placed);\n      });\n      return LB;\n    }\n    getCoord(X, Y) {\n      return [Math.floor(Math.random() * X), Math.floor(Math.random() * Y)];\n    }\n  }\n  GameService.ɵfac = function GameService_Factory(t) {\n    return new (t || GameService)();\n  };\n  GameService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: GameService,\n    factory: GameService.ɵfac\n  });\n  return GameService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}